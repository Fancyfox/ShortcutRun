{
  "code": "var Vector3 = Laya.Vector3;\r\nvar Vec3 = CANNON.Vec3;\r\nimport ES from \"./ES\";\r\nimport MeshUtil from \"../Extensions/MeshUtil\";\r\nexport default class CannonManager {\r\n    constructor() {\r\n        this.gravity = -20;\r\n        this.cannonStep = 1;\r\n        this.que = [];\r\n        this.removeQue = [];\r\n        this.debugSprites = new Array();\r\n        this.touchRay = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(0, 0, 0));\r\n        this.ray = new CANNON.Ray();\r\n        this.result = new CANNON.RaycastResult();\r\n        this.hitInfo = new Laya.HitResult();\r\n        this.outinfo = new Laya.HitResult();\r\n        this.forward = new Laya.Vector3(0, 0, 1);\r\n        this.temp_vec3_1 = new Laya.Vector3(0, 0, 0);\r\n        this.temp_vec3_2 = new Laya.Vector3(0, 0, 0);\r\n        this.temp_vec3_3 = new Laya.Vector3(0, 0, 0);\r\n    }\r\n    static get instance() {\r\n        if (!CannonManager._instance)\r\n            CannonManager._instance = new CannonManager();\r\n        return CannonManager._instance;\r\n    }\r\n    GetTouchPos3D(camera, drawPlane, pos) {\r\n        let pos_2 = new Laya.Vector2(pos.x, pos.y);\r\n        camera.viewportPointToRay(pos_2, this.touchRay);\r\n        this.touchRay = this.touchRay;\r\n        let hitPoint = this.getIntersectWithLineAndPlane(this.touchRay.origin, this.touchRay.direction, this.forward, drawPlane.transform.position);\r\n        return hitPoint;\r\n    }\r\n    getIntersectWithLineAndPlane(point, direct, planeNormal, planePoint) {\r\n        Laya.Vector3.subtract(planePoint, point, this.temp_vec3_1);\r\n        this.temp_vec3_1 = this.temp_vec3_1;\r\n        let mul = Laya.Vector3.dot(direct, planeNormal);\r\n        this.temp_vec3_2.setValue(planeNormal.x / mul, planeNormal.y / mul, planeNormal.z / mul);\r\n        let d = Laya.Vector3.dot(this.temp_vec3_1, this.temp_vec3_2);\r\n        Laya.Vector3.normalize(direct, this.temp_vec3_1);\r\n        this.temp_vec3_1 = this.temp_vec3_1;\r\n        Laya.Vector3.scale(this.temp_vec3_1, d, this.temp_vec3_1);\r\n        this.temp_vec3_1 = this.temp_vec3_1;\r\n        Laya.Vector3.add(this.temp_vec3_1, point, this.temp_vec3_3);\r\n        this.temp_vec3_3 = this.temp_vec3_3;\r\n        let pos = new Laya.Vector3(0, 0, 0);\r\n        pos.setValue(this.temp_vec3_3.x, this.temp_vec3_3.y, this.temp_vec3_3.z);\r\n        return pos;\r\n    }\r\n    enableCannonWorld() {\r\n        console.log('enable cannon world!');\r\n        this.world = new CANNON.World();\r\n        this.world.gravity.set(0, this.gravity, 0);\r\n        this.world.broadphase = new CANNON.NaiveBroadphase();\r\n        this.world.quatNormalizeFast = false;\r\n        this.world.quatNormalizeSkip = 0;\r\n        this.world.defaultContactMaterial.restitution = 0;\r\n        this.world.defaultMaterial.restitution = -1;\r\n        this.cannonRefreshDelta = this.cannonStep / 60;\r\n        ES.instance.on(ES.on_pass_level, this, this.clear);\r\n        ES.instance.on(ES.on_fail_level, this, this.clear);\r\n        Laya.timer.frameLoop(this.cannonStep, this, this.updateCannonWorld);\r\n        this.setWorldIterations(10);\r\n    }\r\n    attachTransform(transform, moveByUser, data, collideCallback = null, group = 1, mask = -1, friction = 0.1, restitution = 0.06) {\r\n        let ret;\r\n        if (data.components) {\r\n            ret = [];\r\n            data.components.map(c => {\r\n                let t = transform.owner.find(c.path);\r\n                if (!t) {\r\n                    console.error('can not find', c.path, 'on', transform.owner);\r\n                    return;\r\n                }\r\n                if (c.transform) {\r\n                    t.transform.localMatrix = new Laya.Matrix4x4().fromArray(c.transform);\r\n                }\r\n                let scale = new Vector3().setFromMatrixScale(t.transform.worldMatrix);\r\n                let body = this.addBody(t['transform'], c, scale.toArray(), moveByUser, group, mask, friction, restitution);\r\n                body.tag = data.tag;\r\n                if (collideCallback)\r\n                    body.addEventListener('collide', collideCallback);\r\n                ret.push({\r\n                    body: body,\r\n                    transform: t['transform']\r\n                });\r\n            });\r\n        }\r\n        return ret;\r\n    }\r\n    addBody(transform, components, scale, moveByUser, group, mask, friction, restitution) {\r\n        let type;\r\n        let mass = 0;\r\n        let angularDrag = 0;\r\n        let drag = 0;\r\n        let linearFactor = new CANNON.Vec3(1, 1, 1);\r\n        let angularFactor = new CANNON.Vec3(1, 1, 1);\r\n        if (components.rigidbody) {\r\n            if (components.rigidbody.isKinematic)\r\n                type = CANNON.Body.KINEMATIC;\r\n            if (components.rigidbody.useGravity && !components.rigidbody.isKinematic)\r\n                type = CANNON.Body.DYNAMIC;\r\n            if (!components.rigidbody.useGravity && !components.rigidbody.isKinematic)\r\n                type = CANNON.Body.STATIC;\r\n            mass = components.rigidbody.mass;\r\n            angularDrag = components.rigidbody.angularDrag;\r\n            drag = components.rigidbody.drag;\r\n            let cons = components.rigidbody.constraints;\r\n            linearFactor.x = cons & 2 ? 0 : 1;\r\n            linearFactor.y = cons & 4 ? 0 : 1;\r\n            linearFactor.z = cons & 8 ? 0 : 1;\r\n            angularFactor.x = cons & 16 ? 0 : 1;\r\n            angularFactor.y = cons & 32 ? 0 : 1;\r\n            angularFactor.z = cons & 64 ? 0 : 1;\r\n        }\r\n        else {\r\n            type = CANNON.Body.STATIC;\r\n        }\r\n        let body = new CANNON.Body({\r\n            position: new CANNON.Vec3(transform.position.x, transform.position.y, transform.position.z),\r\n            quaternion: new CANNON.Quaternion(transform.rotation.x, transform.rotation.y, transform.rotation.z, transform.rotation.w),\r\n            mass: mass,\r\n            type: type,\r\n            material: new CANNON.Material({\r\n                friction: friction,\r\n                restitution: restitution\r\n            }),\r\n            angularVelocity: new CANNON.Vec3(),\r\n            angularDamping: angularDrag,\r\n            velocity: new CANNON.Vec3(),\r\n            linearDamping: drag,\r\n            fixedRotation: false,\r\n            collisionFilterGroup: group,\r\n            collisionFilterMask: mask,\r\n            linearFactor: linearFactor,\r\n            angularFactor: angularFactor\r\n        });\r\n        let trigger = false;\r\n        components.colliders.map(co => {\r\n            if (co.trigger)\r\n                trigger = true;\r\n        });\r\n        body.collisionResponse = !trigger;\r\n        this.addShape(body, components.colliders, scale, transform.owner);\r\n        body.allowSleep = true;\r\n        body.wakeUp();\r\n        this.world.addBody(body);\r\n        this.que.push({\r\n            type: body.type,\r\n            transform: transform,\r\n            body: body,\r\n            moveByUser: moveByUser,\r\n            cposition: new Vec3(),\r\n            cquaternion: new CANNON.Quaternion(),\r\n            lposition: new Vector3(),\r\n            lquaternion: new Laya.Quaternion(),\r\n        });\r\n        return body;\r\n    }\r\n    removeBody(transform) {\r\n        let link = this.queryLinkByTransform(transform);\r\n        if (link) {\r\n            this.removeQue.push(link);\r\n        }\r\n    }\r\n    convertBodyType(transform, type) {\r\n        let link = this.queryLinkByTransform(transform);\r\n        if (link) {\r\n            link.body.type = type;\r\n            switch (type) {\r\n                case CANNON.Body.STATIC:\r\n                    link.moveByUser = true;\r\n                    link.body.mass = 0;\r\n                    break;\r\n                default:\r\n                    link.moveByUser = false;\r\n                    link.body.mass = 1;\r\n                    break;\r\n            }\r\n            link.body.updateMassProperties();\r\n            link.body.wakeUp();\r\n            return link.body;\r\n        }\r\n    }\r\n    queryLinkByTransform(transform) {\r\n        let index = -1;\r\n        for (let i = 0; i < this.que.length; i++) {\r\n            let d = this.que[i];\r\n            if (!d)\r\n                continue;\r\n            if (d.transform === transform) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        if (index != -1) {\r\n            let t = this.que[index];\r\n            t.index = index;\r\n            return t;\r\n        }\r\n    }\r\n    addConstraint(c) {\r\n        this.world.addConstraint(c);\r\n    }\r\n    removeConstraint(c) {\r\n        this.world.removeConstraint(c);\r\n    }\r\n    beforeBodyRemove(body) {\r\n        for (let i = 0; i < this.world.constraints.length; i++) {\r\n            let c = this.world.constraints[i];\r\n            if (c.bodyA === body || c.bodyB === body) {\r\n                this.world.constraints.splice(i--, 1);\r\n            }\r\n        }\r\n    }\r\n    setWorldIterations(iterations) {\r\n        this.world.solver['iterations'] = iterations;\r\n    }\r\n    updateCannonWorld() {\r\n        while (this.removeQue.length > 0) {\r\n            let link = this.removeQue.pop();\r\n            this.beforeBodyRemove(link.body);\r\n            this.world.removeBody(link.body);\r\n            delete this.que[link.index];\r\n        }\r\n        this.world.step(this.cannonRefreshDelta);\r\n        for (let i = 0; i < this.que.length; i++) {\r\n            let d = this.que[i];\r\n            if (!d)\r\n                continue;\r\n            if (d.body.sleepState === CANNON.Body.SLEEPING && !d.moveByUser)\r\n                continue;\r\n            d.moveByUser ? this.bodyFollowTransform(d) : this.transformFollowBody(d);\r\n        }\r\n    }\r\n    bodyFollowTransform(d) {\r\n        d.body.position.x = d.transform.position.x;\r\n        d.body.position.y = d.transform.position.y;\r\n        d.body.position.z = d.transform.position.z;\r\n        d.body.quaternion.x = d.transform.rotation.x;\r\n        d.body.quaternion.y = d.transform.rotation.y;\r\n        d.body.quaternion.z = d.transform.rotation.z;\r\n        d.body.quaternion.w = d.transform.rotation.w;\r\n    }\r\n    transformFollowBody(d) {\r\n        d.lposition.x = d.body.position.x;\r\n        d.lposition.y = d.body.position.y;\r\n        d.lposition.z = d.body.position.z;\r\n        d.lquaternion.x = d.body.quaternion.x;\r\n        d.lquaternion.y = d.body.quaternion.y;\r\n        d.lquaternion.z = d.body.quaternion.z;\r\n        d.lquaternion.w = d.body.quaternion.w;\r\n        d.transform.position = d.lposition;\r\n        d.transform.rotation = d.lquaternion;\r\n    }\r\n    addShape(body, colliders, scale, owner) {\r\n        for (let i = 0; i < colliders.length; i++) {\r\n            let data = colliders[i];\r\n            if (data.type === 'UnityEngine.BoxCollider') {\r\n                let center = new CANNON.Vec3().set(-data.center[0] * scale[0], data.center[1] * scale[1], data.center[2] * scale[2]);\r\n                let size = new CANNON.Vec3(data.size[0] * scale[0] * 0.5, data.size[1] * scale[1] * 0.5, data.size[2] * scale[2] * 0.5);\r\n                let shape = new CANNON.Box(size);\r\n                body.addShape(shape, center);\r\n            }\r\n            else if (data.type === 'UnityEngine.SphereCollider') {\r\n                let center = new CANNON.Vec3().set(-data.center[0] * scale[0], data.center[1] * scale[1], data.center[2] * scale[2]);\r\n                let shape = new CANNON.Sphere(data.radius * scale[0]);\r\n                body.addShape(shape, center);\r\n            }\r\n            else if (data.type === 'UnityEngine.CapsuleCollider') {\r\n                let center = new CANNON.Vec3().set(-data.center[0] * scale[0], data.center[1] * scale[1], data.center[2] * scale[2]);\r\n                let shape = new CANNON.Cylinder(data.radius, data.radius, data.height, 9);\r\n                body.addShape(shape, center);\r\n            }\r\n            else if (data.type === 'UnityEngine.MeshCollider') {\r\n                let vertices = [];\r\n                for (let i = 0; i < data.ver.length; i += 3) {\r\n                    let d = data.ver;\r\n                    let p = new Vec3(d[i], d[i + 1], d[i + 2]);\r\n                    vertices.push(p);\r\n                }\r\n                let tris = MeshUtil.convertFaces(data.tris);\r\n                let shape = new CANNON.ConvexPolyhedron(vertices, tris);\r\n                body.addShape(shape);\r\n            }\r\n            else {\r\n                console.error('unsuport shape type', data.type);\r\n            }\r\n        }\r\n    }\r\n    clear(index) {\r\n        if (index === 0) {\r\n            this.que = [];\r\n            this.world = null;\r\n            Laya.timer.clearAll(this);\r\n        }\r\n    }\r\n}\r\n",
  "references": [
    "D:/WorkSpace/Laya2.6.1/ShortcutRun/src/script/Singleton/ES.ts",
    "D:/WorkSpace/Laya2.6.1/ShortcutRun/src/script/Extensions/MeshUtil.ts",
    "D:/WorkSpace/Laya2.6.1/ShortcutRun/src/script/Singleton/GameManager.ts"
  ]
}
