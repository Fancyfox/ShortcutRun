{
  "code": "var Vector3 = Laya.Vector3;\r\nvar Vector2 = Laya.Vector2;\r\nimport Box3 from \"./Box3\";\r\nimport Mathf from \"./Mathf\";\r\nimport ColorUtil from \"./ColorUtil\";\r\nvar box;\r\nexport default class MeshUtil {\r\n    static genMesh(ver, tris, transform, color) {\r\n        var points = ver[0] instanceof Array ? ver : this.convertPoints(ver);\r\n        var faces = tris[0] instanceof Array ? tris : this.convertFaces(tris);\r\n        var normals = this.computeVertexNormals(points, faces);\r\n        var uvs = this.computeUVs(points, faces);\r\n        var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration(\"POSITION,NORMAL,UV\");\r\n        var vertices = [];\r\n        for (let j = 0; j < ver.length; j += 3) {\r\n            let i = Mathf.Floor(j / 3);\r\n            vertices.push(-ver[j], ver[j + 1], ver[j + 2], normals[i].x, normals[i].y, normals[i].z, uvs[i].x, uvs[i].y);\r\n        }\r\n        let mesh = Laya.PrimitiveMesh._createMesh(vertexDeclaration, new Float32Array(vertices), new Uint16Array(tris));\r\n        let s = new Laya.MeshSprite3D(mesh);\r\n        if (color) {\r\n            let mat = new Laya.BlinnPhongMaterial();\r\n            mat.albedoColor = ColorUtil.fromHex(color).toVector4();\r\n            s.meshRenderer.material = mat;\r\n        }\r\n        let m = new Laya.Matrix4x4().fromArray(transform);\r\n        s.transform.worldMatrix = m;\r\n        return s;\r\n    }\r\n    static computeFaceNormals(ver, faces) {\r\n        var cb = new Vector3(), ab = new Vector3();\r\n        var normals = [];\r\n        for (let i = 0, f = faces.length; i < f; i++) {\r\n            let face = faces[i];\r\n            let vA = ver[face[0]];\r\n            let vB = ver[face[1]];\r\n            let vC = ver[face[2]];\r\n            vC.vsub(vB, cb);\r\n            vA.vsub(vB, ab);\r\n            cb.cross(ab, cb);\r\n            cb.normalize();\r\n            normals.push(cb);\r\n        }\r\n        return normals;\r\n    }\r\n    static computeVertexNormals(ver, faces, areaWeighted = true) {\r\n        let v;\r\n        let vl;\r\n        let f;\r\n        let fl;\r\n        let face;\r\n        let vertices;\r\n        vertices = new Array(ver.length);\r\n        for (v = 0, vl = ver.length; v < vl; v++) {\r\n            vertices[v] = new Vector3();\r\n        }\r\n        if (areaWeighted) {\r\n            var vA, vB, vC;\r\n            var cb = new Vector3(), ab = new Vector3();\r\n            for (f = 0, fl = faces.length; f < fl; f++) {\r\n                face = faces[f];\r\n                vA = ver[face[0]];\r\n                vB = ver[face[1]];\r\n                vC = ver[face[2]];\r\n                vC.vsub(vB, cb);\r\n                vA.vsub(vB, ab);\r\n                cb.cross(ab, cb);\r\n                vertices[face[0]].vadd(cb, vertices[face[0]]);\r\n                vertices[face[1]].vadd(cb, vertices[face[1]]);\r\n                vertices[face[2]].vadd(cb, vertices[face[2]]);\r\n            }\r\n        }\r\n        else {\r\n            let normals = this.computeFaceNormals(ver, faces);\r\n            for (f = 0, fl = faces.length; f < fl; f++) {\r\n                face = faces[f];\r\n                vertices[face[0]].vadd(normals[f], vertices[face[0]]);\r\n                vertices[face[1]].vadd(normals[f], vertices[face[1]]);\r\n                vertices[face[2]].vadd(normals[f], vertices[face[2]]);\r\n            }\r\n        }\r\n        for (v = 0, vl = vertices.length; v < vl; v++) {\r\n            vertices[v].normalize();\r\n        }\r\n        return vertices;\r\n    }\r\n    static computeUVs(ver, faces) {\r\n        let normals = this.computeVertexNormals(ver, faces);\r\n        let uvs = [];\r\n        if (!box)\r\n            box = new Box3();\r\n        box.setFromPoints(ver);\r\n        let size = box.getSize();\r\n        for (let i = 0, il = ver.length; i < il; i++) {\r\n            let normal = normals[i];\r\n            var components = ['x', 'y', 'z'].sort((a, b) => Math.abs(normal[b]) - Math.abs(normal[a]));\r\n            var x = components[1], y = components[2];\r\n            var v1 = ver[i];\r\n            let a = (v1[x] + size[x] * 0.5) / size[x];\r\n            let b = (v1[y] + size[y] * 0.5) / size[y];\r\n            uvs.push(new Vector2(a, b));\r\n        }\r\n        ;\r\n        return uvs;\r\n    }\r\n    static convertPoints(ver) {\r\n        var points = [];\r\n        for (let i = 0; i < ver.length; i += 3) {\r\n            let p = new Vector3(ver[i], ver[i + 1], ver[i + 2]);\r\n            points.push(p);\r\n        }\r\n        return points;\r\n    }\r\n    static convertFaces(tris) {\r\n        var faces = [];\r\n        for (let i = 0; i < tris.length; i += 3) {\r\n            let tri = [];\r\n            let f1 = tris[i];\r\n            let f2 = tris[i + 1];\r\n            let f3 = tris[i + 2];\r\n            tri.push(f1);\r\n            tri.push(f2);\r\n            tri.push(f3);\r\n            faces.push(tri);\r\n        }\r\n        return faces;\r\n    }\r\n    static convertNormals(normals) {\r\n        var ret = [];\r\n        for (let i = 0; i < normals.length; i += 3) {\r\n            let n = new Vector3(normals[i], normals[i + 1], normals[i + 2]);\r\n            ret.push(n);\r\n        }\r\n        return ret;\r\n    }\r\n    static ccw(a, b, c) {\r\n        let m00 = a.x;\r\n        let m01 = a.y;\r\n        let m02 = a.z;\r\n        let m10 = b.x;\r\n        let m11 = b.y;\r\n        let m12 = b.z;\r\n        let m20 = c.x;\r\n        let m21 = c.y;\r\n        let m22 = c.z;\r\n        let f = m00 * (m11 * m22 - m12 * m21)\r\n            + m01 * (m12 * m20 - m10 * m22)\r\n            + m02 * (m10 * m21 - m11 * m20);\r\n        return f > 0 ? 1 : f < 0 ? -1 : 0;\r\n    }\r\n}\r\n",
  "references": [
    "D:/WorkSpace/Laya2.6.1/ShortcutRun/src/script/Extensions/Box3.ts",
    "D:/WorkSpace/Laya2.6.1/ShortcutRun/src/script/Extensions/Mathf.ts",
    "D:/WorkSpace/Laya2.6.1/ShortcutRun/src/script/Extensions/ColorUtil.ts"
  ]
}
